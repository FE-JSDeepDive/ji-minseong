# Ch-14 전역 변수의 문제점

---

## 변수의 생명 주기

- 변수는 자신이 선언된 위치에서 생성되고 소한다.
- 지역 변수는 함수가 호출되면 생성되고, 함수가 종료되면 소멸한다.
- 즉, 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.
- 더 정확히 말하면, 변수의 생명 주기는 메모리 공간이 확보된 시점 부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점이다.

1. 함수 내부에서 선언된 지역 변수는 함수가 생성한 스코프에 등록
2. 변수는 자신이 등록된 스코프가 소멸될때 유효
3. 할당된 메모리 공간은 그 누구도 참조하지 않으면 가비지 콜렉터에 의해 해제되어 가용 메모리 풀에 반환

**호이스팅과 스코프**
호이스팅은 변수 선언이 **스코프의** 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유한 특징이다.

**전역 변수의 생명 주기**
var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.

---

## 전역 변수의 문제점

- **암묵적 결합**

  - -> 을 허용한다 그렇다면, 유효범위가 커진다.
  - -> 그러면 가독성은 나빠진다 , 의도치않게 상태가 변경될 수 있는 위험성도 커진다.

- **긴 생명 주기**

  - 긴 생명 주기로 메모리 리소스를 오래 소비한다.
  - 상태변경에 의해 오류가 발생할 확률이 높아진다.

- **스코프 체인 상에서 종점에 존재**

  - 전역 변수의 검색 속도가 가장 느리다
  - 왜? 스코프 체인에서 종점, 즉 가장 상위에 존재하기 때문

- **네임스페이스 오염**
  - 파일이 분리되어 있어도 전역을 공유
  - 그러면, 동일이름으로 변수가 있을 수 있기에 오염된다

---

## 전역 변수의 사용을 억제하는 방법

위와 같은 이유로 전역 변수 사용을 억제해야한다.

- **즉시 실행 함수** -> 주로 라이브러리 등에서 사용한다.
- **네임스페이스 객체** -> 또다른 네임스페이스 객체를 아래와 같이 만든다.

  ```javascript
  var MYAPP = {};

  MYAPP.name = "Lee";

  console.log(MYAPP.name);
  ```

  => 그다지 유용하지 않다, 결국 전역 변수에 객체가 할당됨으로

- **모듈 패턴**

  - 클래스를 모방
  - 변수와 함수를 모아 즉시 실행 함수로 모듈화
  - 클로저 기반으로 동작

  ```javascript
  var Counter = function () {
    var num = 0; // private 변수

    return {
      increase() {
        return ++num;
      },
    };
  };
  ```

  - 위 예제는 객체를 반환한다
  - 객체의 프로퍼티는 public, 변수는 private 형식으로 사용할 수 있다

  **클로저** (출처 : MDN) <br/>
  클로저는 주변 상태(어휘적 환경)에 대한 참조와 함께 묶인(포함된) 함수의 조합입니다. 즉, 클로저는 내부 함수에서 외부 함수의 범위에 대한 접근을 제공합니다. JavaScript에서 클로저는 함수 생성 시 함수가 생성될 때마다 생성됩니다.

- **ES6 모듈**

  - ES6을 사용하면 전역 변수를 사용할 수 없다
  - var는 더이상 전역 변수가 아니며, window 객체의 프로퍼티도 아니다
  - ES6 모듈은 아직 트랜스파일링, 번들링 기능을 위해서 보통 Webpack등의 모듈 번들러를 사용한다.

  **Webpack**
  webpack은 모던 JavaScript 애플리케이션을 위한 정적 모듈 번들러 입니다. webpack이 애플리케이션을 처리할 때, 내부적으로는 프로젝트에 필요한 모든 모듈을 매핑하고 하나 이상의 번들을 생성하는 디펜던시 그래프를 만듭니다.
