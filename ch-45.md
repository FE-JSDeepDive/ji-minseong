# Ch-45 프로미스

---

## 비동기 처리를 위한 콜백 패턴은 안좋을 수 있다.
- 자바스크립트는 싱글 스레드 기반의 언어로, 비동기 처리를 위해 콜백 함수를 많이 사용
- 왜 콜백 패턴?
  - 비동기 작업의 결과를 처리하기 위해 콜백 함수를 사용
  - 예시: 파일 읽기, 네트워크 요청 등
  - ex) `fs.readFile('file.txt', (err, data) => { if (err) throw err; console.log(data); });`
- 콜백 패턴의 문제점
  - 콜백 지옥(Callback Hell): 중첩된 콜백 함수로 인해 코드가 복잡해지고 가독성이 떨어짐
  - 에러 처리의 어려움: 각 콜백마다 에러 처리를 해야 하므로 코드가 중복되고 복잡해짐
  - 유지보수의 어려움: 콜백 함수가 많아질수록 코드의 흐름을 이해하기 어려워짐 

### 콜백 헬
```javascript
const get = url => {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.send();

  xhr.onload = () => {
    if (xhr.status === 200) {
      console.log(xhr.response);
    } else {
      console.error(new Error(xhr.statusText));
    }
  };
}

//id가 1인 post를 취득
get('https://jsonplaceholder.typicode.com/posts/1');
/*
  {
    "userId": 1,
    "id": 1,
    "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",
    "body": "quia et suscipit\nsuscipit..."
  }
*/
```
- 위 예시에서 `get` 함수는 콜백 패턴을 사용하여 비동기적으로 데이터를 가져옴
- get 함수는 비동기 함수 -> 왜? `XMLHttpRequest` 객체의 **`onload` 이벤트 핸들러가 비동기적으로 호출되기 때문**
  -> 비동기 함수(A)를 호출 -> 함수 내부 비동기 동작하는 코드(B)가 완료되지 않아도 종료 -> 따라서 비동기 함수(A) 내부 비동기 코드(B)의 실행 결과를 알 수 없음 -> 그래서 (B)의 실행 결과를 외부에 반환하거나, 상위 스코프 로 전달할 수 없음
-> 즉, get 함수의 onload 이벤트 핸들러 내부에서만 xhr.response를 사용할 수 있음


- 만약 get 함수가 데이터를 반환하도록 만들고 싶다면?
```javascript
const get = url => {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.send();

  xhr.onload = () => {
    if (xhr.status === 200) {
      return xhr.response; // 이 return은 onload 핸들러 내부에서만 유효
    } else {
      throw new Error(xhr.statusText); // 이 throw도 onload 핸들러 내부에서만 유효
    }
  };
}

const result = get('https://jsonplaceholder.typicode.com/posts/1');
console.log(result); // undefined -> get 함수는 아무것도 반환하지 않음
```
- 위 예시에서 get 함수는 아무것도 반환하지 않음 -> onload 핸들러 내부의 return 문은 get 함수의 반환값에 영향을 미치지 않음
- 이번엔 상위 스코프의 변수에 할당해보자.
```javascript
let todos;
const get = url => {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.send();

  xhr.onload = () => {
    if (xhr.status === 200) {
      todos = JSON.parse(xhr.response); // 상위 스코프의 todos 변수에 할당
    } else {
      console.error(new Error(xhr.statusText));
    }
  };
}

get('https://jsonplaceholder.typicode.com/posts/1');
console.log(todos); // undefined -> 아직 데이터가 할당되지 않음 console.log가 먼저 실행되기 때문
```
- 위 예시에서 get 함수가 호출된 후 즉시 console.log(todos)가 실행 -> 아직 onload 핸들러가 실행되지 않았기 때문에 todos 변수는 여전히 undefined
  - 왜? 
    - get 호출 -> get 실행 컨텍스트 생성 -> get 실행 컨텍스트가 실행 컨텍스트 스택에 푸쉬 -> xhr.onload 이벤트 핸들러 프로퍼티에 이벤트 핸들러가 바인딩 (함수 실행 과정) -> get 함수 종료 -> get 실행 컨텍스트가 실행 컨텍스트 스택에서 팝 -> console.log(todos) 호출 -> console.log 실행 컨텍스트 생성 -> console.log 실행 컨텍스트가 실행 컨텍스트 스택에 푸쉬 
    -> **만약, load 이벤트가 발생했더라도 xhr.onload 이벤트 핸들러 프로퍼티에 바인딩한 이벤트 핸들러는 결코 console.log보다 먼제 실행 되지 않음** 왜? - 이벤트 루프의 동작 원리 때문
    - 이벤트 루프: 자바스크립트 런타임 환경에서 비동기 작업이 완료되면 해당 작업의 콜백 함수를 이벤트 큐에 넣음
    - 이벤트 루프는 **실행 컨텍스트 스택이 비어 있을 때** 이벤트 큐에서 콜백 함수를 꺼내 실행 컨텍스트 스택에 푸쉬
    - 따라서, get 함수가 종료되고 console.log가 실행된 후에야 (실행 컨텍스트가 비어 있기 때문) 이벤트 큐에 있는 xhr.onload 이벤트 핸들러가 실행됨
- 결론  
  - 따라서 비동기 함수의 실행 결과를 상위 스코프에 전달하는 것도 불가능

- 콜백 패턴을 쓰는 예시
```javascript
const get = (url, successCallback, errorCallback) => {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.send();

  xhr.onload = () => {
    if (xhr.status === 200) {
      successCallback(xhr.response); // 성공 콜백 호출
    } else {
      errorCallback(new Error(xhr.statusText)); // 에러 콜백 호출
    }
  };
}

get(
  'https://jsonplaceholder.typicode.com/posts/1',
  console.log,        // 성공 콜백
  console.error      // 에러 콜백
);
```

- 콜백 패턴의 문제점
  - 콜백 지옥(Callback Hell): 중첩된 콜백 함수로 인해 코드가 복잡해지고 가독성이 떨어짐
  - 콜백 함수를 통해 / 비동기 처리 결과에 대한 처리 / 를 수행하는 비동기 함수 / 가 비동기 처리 결과를 가지고 / 또다시 비동기 함수 호출 => 콜백 함수 중첩
ex)
```javascript
const get = (url,callback) => {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.send();

  xhr.onload = () => {
    if (xhr.status === 200) {
      callback(null, xhr.response); // 성공 콜백 호출
    } else {
      callback(new Error(xhr.statusText)); // 에러 콜백 호출
    }
  };
}

const url = 'https://jsonplaceholder.typicode.com/posts/1';

// id가 1인 post의 userId를 취득 -> userId로 user 정보를 취득 -> post에 대한 comments를 취득
get(`${url}/posts/1`, ({userId}) => {
  console.log(userId);
  get(`${url}/users/${userId}`, (user) => {
    get(`${url}/comments?postId=${post.id}`, (comments) => {
      console.log('User:', user);
      console.log('Comments:', comments);
    });
  });
});
```
### 에러 처리 문제
=> 위의 예시대로 콜백 패턴을 사용하면 에러 처리가 복잡해짐
```javascript
try{
  setTimeout(() => {
    throw new Error('Error!');
  }, 1000);
}catch(e){
  // 이 catch 블록은 동작하지 않음 즉, 에러를 잡지 못함
  console.error(e);
}
```
- 왜? (내 생각)
  1. seTimeout은 비동기
  2. setTimeout의 콜백 함수 호출
  3. setTimeout의 콜백 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸쉬
  4. try-catch 블록 종료
  5. setTimeout의 콜백 함수 내부에서 에러 발생 but, 이미 try-catch 블록이 종료되어 더 이상 유효하지 않음
  6. setTimeout의 콜백 함수 실행 컨텍스트가 실행 컨텍스트 스택에서 팝

- 왜? (정답)
  1. 비동기 함수 setTimeout 호출
  2. setTimeout 함수의 실행 컨텍스트가 생성 -> 콜 스택에 푸쉬 -> 실행
  3. setTimeout 함수는 비동기 함수이므로 즉시 종료 (콜백 함수 호출 기다리지 않고) -> 콜 스택에서 제거
  4. 타이머 만료되면 setTimeout의 콜백 함수가 태스크 큐에 푸쉬
    - 이벤트 루프가 태스크 큐를 확인하고 콜 스택이 비어있으면 콜백 함수를 실행
  5. setTimeout 함수의 콜백 함수가 실행 (이미 setTimeout 함수의 실행 컨텍스트는 콜 스택에서 제거된 상태)
    - 즉, 이때 호출한 함수는 콜백 함수이지 setTimeout 함수가 아님 -> 에러는 **호출자** 방향으로 전파
  => 콜백 함수가 일으키는 에러는 try-catch 블록에서 잡을 수 없음
- 따라서, 콜백 패턴을 사용하면 에러 처리가 어려워짐

**=> 위 모든 문제를 해결하기 위해 Promise를 사용한다.(ES6)도입**

## 프로미스의 생성
```javascript
const promise = new Promise((resolve, reject) => { // new 연산자와 함께 호출하면 Promise 객체를 생성
  // 비동기 작업 수행
  // 작업이 성공하면 resolve 호출
  // 작업이 실패하면 reject 호출
});
```
- Promise는 호스트 객체가 아닌 ECMAScript 사양에 정의된 빌트인 객체
  - 호스트 객체 : 자바스크립트 런타임 환경(브라우저, Node.js 등)이 제공하는 객체 ex) DOM, BOM, fs 등
  - 빌트인 객체 : 자바스크립트 언어 자체가 제공하는 객체 ex) Object, Array, Function, Promise 등
- Promise 생성자 함수가 인수로 전달 받은 콜백 함수를 executor라고 부름
    - resolve : 비동기 작업이 성공했을 때 호출하는 함수
    - reject : 비동기 작업이 실패했을 때 호출하는 함수
ex)
```javascript
// GET 요청을 비동기적으로 처리하는 promiseGet 함수
const promiseGet = url => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.send();

    xhr.onload = () => {
      if (xhr.status === 200) {
        resolve(JSON.parse(xhr.response)); // 비동기 작업이 성공했을 때 호출
      } else {
        reject(new Error(xhr.statusText)); // 비동기 작업이 실패했을 때 호출
      }
    };
  });
};

// promiseGet 함수는 Promise 객체를 반환
const promise = promiseGet('https://jsonplaceholder.typicode.com/posts/1');
console.log(promise); // Promise { <pending> }
```
- promiseGet 함수는 Promise 객체를 반환 -> 이 Promise 객체는 비동기 작업의 완료 여부를 나타냄
- Promise 객체의 상태(state)
  - pending: 비동기 작업이 아직 완료되지 않은 상태(초기 상태)
  - fulfilled: 비동기 작업이 성공적으로 완료된 상태
  - rejected: 비동기 작업이 실패한 상태
    - settled : 이행(fulfilled)과 거부(rejected)를 통틀어 부르는 상태 -> **더는 다른 상태로 변경되지 않음**
- Promise 객체의 상태는 불변(immutable) -> 한 번 이행되거나 거부되면 다시 대기 상태로 돌아갈 수 없음
- Promise 객체의 상태는 executor 내부에서만 변경 가능
  - **resolve 함수가 호출되면 상태가 이행(fulfilled)으로 변경**
  - **reject 함수가 호출되면 상태가 거부(rejected)로 변경**
=> 위 개념으로 미루어 보았을 때 **Promise는 비동기 처리 상태와 처리 결과를 관리하는 객체이다.**

## 프로미스의 후속 처리 메서드
프로미스가 fulfilled 또는 rejected 상태가 되면 후속 처리 메서드를 통해 처리 결과를 다룰 수 있음
- then 메서드: 프로미스가 이행(fulfilled)되었을 때 호출되는 콜백 함수를 등록
- catch 메서드: 프로미스가 거부(rejected)되었을 때 호출되는 콜백 함수를 등록
- finally 메서드: 프로미스가 이행(fulfilled)되었든 거부(rejected)되었든 상관없이 항상 호출되는 콜백 함수를 등록

### then 메서드
- 2개의 콜백 함수를 인수로 전달 받을 수 있음
  - 첫 번째 콜백 함수: 프로미스가 이행(fulfilled)되었을 때 호출
  - 두 번째 콜백 함수: 프로미스가 거부(rejected)되었을 때 호출
- 언제나 프로미스를 반환
```javascript
new Promise(resolve => resolve('fulfilled'))
  .then(value => {
    console.log(value); // 'fulfilled
  }, error => {
    console.error(error); // 이 콜백 함수는 호출되지 않음
  });

  new Promise((_, reject) => reject(new Error('rejected')))
  .then(value => {
    console.log(value); // 이 콜백 함수는 호출되지 않음
  }, error => {
    console.error(error); // Error: rejected
  });
```

### catch 메서드
- 1개의 콜백 함수를 인수로 전달 받음
  - 이 콜백 함수는 프로미스가 거부(rejected)되었을 때 호출
  - then 메서드의 두 번째 콜백 함수와 동일한 역할
- 언제나 프로미스를 반환
```javascript
new Promise((_, reject) => reject(new Error('rejected')))
  .catch(error => {
    console.error(error); // Error: rejected
  });
```

### finally 메서드
- 1개의 콜백 함수를 인수로 전달 받음
  - 이 콜백 함수는 프로미스가 이행(fulfilled)되었든 거부(rejected)되었든 상관없이 항상 **1회** 호출
- 언제나 프로미스를 반환
```javascript
new Promise(resolve => resolve('fulfilled'))
  .finally(() => {
    console.log('finally'); // 'finally'
  })
  .then(value => {
    console.log(value); // 'fulfilled'
  });
```

### 예시 
```javascript
const promiseGet = url => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.send(); 
    xhr.onload = () => {
      if (xhr.status === 200) {
        resolve(JSON.parse(xhr.response)); // 비동기 작업이 성공했을 때 호출
      } else {
        reject(new Error(xhr.statusText)); // 비동기 작업이 실패했을 때 호출
      }
    };
  });
};

promiseGet('https://jsonplaceholder.typicode.com/posts/1')
  .then(post => {
    console.log('Post:', post);
    return promiseGet(`https://jsonplaceholder.typicode.com/users/${post.userId}`);
  })
  .then(user => {
    console.log('User:', user);
    return promiseGet(`https://jsonplaceholder.typicode.com/comments?postId=${post.id}`);
  })
  .then(comments => {
    console.log('Comments:', comments);
  })
  .catch(error => {
    console.error('Error:', error);
  })
  .finally(() => {
    console.log('Done');
  });
```

## 프로미스의 에러 처리
- 비동기 처리 결과 에러 : then, catch, finally 를 사용하여 수행
- 비동기 처리 에러 : then 메서드 두번째 콜백 함수 이용

```javascript
// 방법 1 : then 메서드의 두 번째 콜백 함수 이용
const wrongUrl = 'https://jsonplaceholder.typicode.com/pos'; // 잘못된 URL

promiseGet(wrongUrl).then(
  res => console.log(res), // 이 콜백 함수는 호출되지 않음
  err => console.error('Error:', err) // Error: Not Found
);
```
- 위 예시에서 잘못된 URL로 인해 비동기 작업이 실패 -> then 메서드의 두 번째 콜백 함수가 호출되어 에러를 처리
- 만약, then 메서드의 두 번째 콜백 함수를 생략하면?
```javascript
// 방법 2 : catch 메서드 이용
promiseGet(wrongUrl)
  .then(res => console.log(res)) // 이 콜백 함수는 호출되지 않음
  .catch(err => console.error('Error:', err)); // Error: Not Found
```
=> 내부적으로는 catch를 사용하면 `then(undefined, onRejected)`와 동일하게 동작
```javascript
// 방법 2-2: catch 메서드 이용 (내부적으로는 then(undefined, onRejected)와 동일)
promiseGet(wrongUrl)
  .then(res => console.log(res)) // 이 콜백 함수는 호출되지 않음
  .then(undefined, err => console.error('Error:', err)); // Error: Not Found
```

- 방법 1 사용시 
  - **가독성에 저하**
  - **첫번째 콜백 함수의 에러 처리 못함**

```javascript
promiseGet(wrongUrl).then(
  res => console.log(res), // 이 콜백 함수는 호출되지 않음
  err => console.error('Error:', err) // Error: Not Found
); // 두번째 콜백 함수가 첫번째 콜백 함수의 에러를 처리하지 못함
```

=> catch 사용시
  - 가독성 향상
  - 첫번째 콜백 함수의 에러 처리 가능
```javascript
promiseGet(wrongUrl)
  .then(res => { console.log(res); })// 이 콜백 함수는 호출되지 않음
  .catch(err => console.error('Error:', err)); // Error: Not Found 또는 Error in then 
```

**=> 결론 catch 사용!**

## 프로미스 체이닝
- then, catch, finally 메서드는 언제나 프로미스를 반환
- 따라서, 후속 처리 메서드를 연속적으로 호출하는 프로미스 체이닝(Promise Chaining) 가능
- 프로미스 체이닝을 사용하면 콜백 지옥(Callback Hell)을 피할 수 있음
```javascript
const url = 'https://jsonplaceholder.typicode.com/posts/1';

// id가 1인 post의 userId를 취득 
promiseGet(`${url}/posts/1`)
.then(({userId}) => promseGet(`${url}/users/${userId}`)) // userId로 user 정보를 취득
.then(userInfo => console.log(userInfo)) // post에 대한 comments를 취득
.catch(err => console.log(err)); // 에러 처리

```
- 콜백 헬을 피하지만, 콜백을 사용하긴 함 => **그래서 나온게 async/await!**

```javascript
const url = 'https://jsonplaceholder.typicode.com/posts/1';

(async () => {
  // id가 1인 post의 userId를 취득
  const { userId } = await promiseGet(`${url}/posts/1`);
  // userId로 user 정보를 취득
  const userInfo = await promiseGet(`${url}/users/${userId}`);
  console.log(userInfo);
})();
```

## 프로미스의 정적 메서드
- 주로 생성자 함수로 사용되지만, 함수도 객체 -> 메서드 가짐
- 총 5개 정적 메서드 가짐
  - Promise.resolve(value): 인수로 전달된 값을 이행(fulfilled) 상태의 프로미스로 감싼 후 반환
  - Promise.reject(reason): 인수로 전달된 값을 거부(rejected) 상태의 프로미스로 감싼 후 반환
  - Promise.all(iterable): 인수로 전달된 모든 프로미스가 이행(fulfilled)되었을 때 이행(fulfilled) 상태의 프로미스를 반환, 하나라도 거부(rejected)되면 즉시 거부(rejected) 상태의 프로미스를 반환
  - Promise.race(iterable): 인수로 전달된 프로미스 중 가장 먼저 이행(fulfilled) 또는 거부(rejected)된 프로미스를 반환

### Promise.resolve / Promise.reject
```javascript
// Promise.resolve
const resolvedPromsise = Promise.resolve([1,2,3]);
resolvedPromsise.then(value => console.log(value)); // [1,2,3]

const resolvedPromsise = new Promise(resolve => resolve([1,2,3]));
resolvedPromsise.then(value => console.log(value)); // [1,2,3]

// Promise.reject
const rejectedPromsise = Promise.reject(new Error('rejected'));
rejectedPromsise.catch(error => console.error(error)); // Error: rejected

const rejectedPromsise = new Promise((_, reject) => reject(new Error('rejected')));
rejectedPromsise.catch(error => console.error(error)); // Error: rejected
``` 

### Promise.all
```javascript
// AI 변환 시작 함수
  const startAIConversion = useCallback(async () => {
    if (!selectedImage) return;

    try {
      setIsUploading(true);

      // URL을 File 객체로 변환
      const response = await fetch(selectedImage.url);
      const blob = await response.blob();
      const file = new File([blob], `image-${selectedImage.id}.jpg`, { type: "image/jpeg" });

      // 이미지 업로드
      console.log("이미지 업로드 중...");
      const imageUrl = await uploadImageAndGetUrl(file);
      setUploadedImageUrl(imageUrl);
      setIsUploading(false);

      console.log("AI 변환 시작:", imageUrl);

      // 두 가지 AI 변환을 병렬로 시작
      await Promise.all([
        handleSingleAIConvert(imageUrl, "first"),
        handleSingleAIConvert(imageUrl, "second"),
      ]);

    } catch (error) {
      console.error("이미지 업로드 중 오류 발생:", error);
      setIsUploading(false);
    }
  }, [selectedImage, uploadImageAndGetUrl, handleSingleAIConvert]);
```

- Promise.all은 여러 비동기 작업을 병렬로 처리할 때 유용
- 세 개의 비동기 처리를 순차 처리 -> 3초 + 2초 + 1초 라면 총 6초 걸림
- 세 개의 비동기 처리를 병렬 처리 -> 가장 오래 걸리는 3초 걸림
```javascript
const asyncTask1 = () => new Promise(resolve => setTimeout(() => resolve('Task 1 complete'), 3000));
const asyncTask2 = () => new Promise(resolve => setTimeout(() => resolve('Task 2 complete'), 2000));
const asyncTask3 = () => new Promise(resolve => setTimeout(() => resolve('Task 3 complete'), 1000));    

// 순차 처리
asyncTask1()
  .then(result1 => {
    console.log(result1);
    return asyncTask2();
  })
  .then(result2 => {
    console.log(result2);
    return asyncTask3();
  })
  .then(result3 => {
    console.log(result3);
  });
// 3초 후: Task 1 complete
// 5초 후: Task 2 complete
// 6초 후: Task 3 complete

// 병렬 처리
Promise.all([asyncTask1(), asyncTask2(), asyncTask3()])
  .then(results => {
    results.forEach(result => console.log(result));
  });
// 3초 후: Task 1 complete
// 3초 후: Task 2 complete
// 3초 후: Task 3 complete
```
- 원리
  - **프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달 받음**
  - Promise.all은 인수로 전달된 모든 프로미스가 이행(fulfilled)되었을 때 이행(fulfilled) 상태의 프로미스를 반환
  - 하나라도 거부(rejected)되면 즉시 거부(rejected) 상태 -> 만약 거부된 프로미스 있어도 병렬 처리 하고 싶다면?    
    **->  `Promise.allSettled` 사용**
  - 모든 프로미스의 이행 결과를 배열로 반환
  - 즉, Promise.all의 소요 시간 = 가장 오래 걸리는 프로미스의 소요 시간(보다 조금 더 걸림)
    - **좀 더 걸리는 이유 : 모든 프로미스가 이행(fulfilled)되었는지 확인하는데 걸리는 시간 때문**
    
### Promise.race
- 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달 받음
- 인수로 전달된 프로미스 중 가장 먼저 이행(fulfilled) 또는 거부(rejected)된 프로미스를 반환

### Promise.allSettled
- **ES11(2020) 도입**
- 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달 받음
- 인수로 전달된 모든 프로미스가 이행(fulfilled) 또는 거부(rejected)될 때까지 기다린 후, 모든 프로미스의 이행 결과를 배열로 반환
- 각 이행 결과는 객체로 표현
  - { status: 'fulfilled', value: ... } : 프로미스가 이행(fulfilled)된 경우
  - { status: 'rejected', reason: ... } : 프로미스가 거부(rejected)된 경우
```javascript
const asyncTask1 = () => new Promise((resolve) => setTimeout(() => resolve('Task 1 complete'), 3000));
const asyncTask2 = () => new Promise((_, reject) => setTimeout(() => reject(new Error('Task 2 failed')), 2000));
const asyncTask3 = () => new Promise((resolve) => setTimeout(() => resolve('Task 3 complete'), 1000));

Promise.allSettled([asyncTask1(), asyncTask2(), asyncTask3()])
  .then(results => {
    results.forEach(result => {
      if (result.status === 'fulfilled') {
        console.log('Success:', result.value);
      } else {
        console.error('Error:', result.reason);
      }
    });
  });
// 3초 후:
// Success: Task 1 complete
// Error: Error: Task 2 failed
// Success: Task 3 complete
```

## 마이크로태스크 큐
```javascript
setTimeout(() => console.log(1), 0);

Promise.resolve()
.then(() => console.log(2))
.then(() => console.log(3));
```
- 내 예상 
  1. setTimeout 실행 컨텍스트 생성 및 등록
  2. setTimeout 종료 및 실행 컨텍스 팝
  3. console.log(2) 실행 컨텍스트 등록 -> 종료 -> 팝  
  4. 약 4ms뒤 콜백 함수 console.log(1) 태스크 큐에 등록 -> 종료 -> 팝
  5. console.log(3) 실행 컨텍스트 등록 -> 종료 -> 팝

## fetch
- Client Side Web API
- XMLHttpRequest 객체 기반의 비동기 통신을 더 쉽게 사용할 수 있도록 만든 최신 API
- **fetch 함수는 HTTP 응답을 나타내는 Response객체를 래핑한 Promise 객체를 반환**