# Ch-38 브라우저의 렌더링 과정

---

## 간략한 렌더링 과정 
1. HTML 파싱
   - HTML 문서를 읽고 DOM 트리를 생성
   - DOM 트리는 HTML 요소를 노드로 표현한 트리 구조
   - DOM 트리는 HTML 문서의 구조를 나타내는 객체
2. CSS 파싱
   - CSS 문서를 읽고 CSSOM 트리를 생성
   - CSSOM 트리는 CSS 규칙을 노드로 표현한 트리 구조
   - CSSOM 트리는 CSS 문서의 구조를 나타내는 객체
3. 렌더 트리 생성
   - DOM 트리와 CSSOM 트리를 결합하여 렌더 트리를 생성
   - 렌더 트리는 화면에 표시될 요소를 나타내는 객체
   - 렌더 트리는 DOM 트리와 CSSOM 트리를 결합하여 생성
4. 레이아웃
   - 렌더 트리를 기반으로 각 요소의 위치와 크기를 계산
   - 레이아웃은 렌더 트리를 기반으로 각 요소의 위치와 크기를 계산
5. 페인팅
   - 레이아웃을 기반으로 각 요소를 화면에 그리기
   - 페인팅은 레이아웃을 기반으로 각 요소를 화면에 그리기
6. 합성
   - 페인팅된 요소를 합성하여 최종 화면을 생성
   - 합성은 페인팅된 요소를 합성하여 최종 화면을 생성
   - 합성은 GPU에서 수행
   - 합성은 GPU에서 수행하여 성능을 향상시킴
7. 화면에 표시  
   - 최종 화면을 브라우저에 표시


---

## HTTP 1.1과 HTTP 2.0의 차이점 
| 항목 | HTTP 1.1 | HTTP 2.0 |
|------|----------|----------|
| 연결 | 단일 연결(커넥션당 하나의 요청과 응답만 처리, 즉 여러 리소스 불가능) | 멀티플렉싱 |
| 헤더 압축 | 없음 | 있음 |
| 서버 푸시 | 없음 | 있음 |
| 요청/응답 | 텍스트 기반 | 이진 기반 |
| 요청/응답 헤더 | 텍스트 기반 | 이진 기반 |
| 요청/응답 헤더 압축 | 없음 | 있음 |
| 요청/응답 헤더 크기 | 없음 | 있음 |
| 요청/응답 헤더 크기 제한 | 없음 | 있음 |

---

## HTML 파싱과 DOM 생성 과정
- **바이트 -> 문자 -> 토큰 -> 노드 -> DOM 트리**
- **DOM은 HTML 문서를 파싱한 결과물**

---

## CSS 파싱과 CSSOM 생성 과정
- **바이트 -> 문자 -> 토큰 -> 노드 -> CSSOM 트리**
- **CSSOM은 CSS 문서를 파싱한 결과물**

- **CSSOM 생성시 DOM 로드 하는 태그를 만나면, 생성을 일시 중지**
- **HTML 파싱과 동일한 파싱 과정을 거쳐 CSSOM 생성**

---

## 렌더 트리 생성 과정
- **렌더 트리는 DOM과 CSSOM을 결합하여 생성**
- **렌더 트리는 화면에 표시될 요소를 나타내는 객체**
  => 이후 각 HTML 요소의 레이아웃(위치와 크기) 계산하는데 사용 <br/>
  => 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 입력

---

## 레이아웃과 성능
- 레이앙웃 계산과 페인팅을 다시 실행하는 리렌더링은
- 브라우저 성능에 큰 영향을 미침
  
  - ex) CSS 속성 변경
  - 자바스크립트에 의한 노드 추가 및 삭제
  - 브라우저 리사이징에 의한 뷰포트 크기 변경
  - HTML 요소의 레이아웃의 변경을 유발하는 CSS 속성 변경
    - ex) width, height, margin, padding, border, top, left, right, bottom
    - display, position, float, clear
  

---

## 자바스크릅티 파싱과 실행
- DOM API 제공
  - DOM API는 DOM을 조작하는 API
  - DOM API는 DOM을 조작하는 메서드와 속성으로 구성
  - 이미 생성된 DOM을 조작하는 메서드와 속성을 제공

1. 자바스크립트 코드 파싱
2. AST 생성
3. 인터프리터가 실행 할수 있는 중간 코드(바이트코드) 생성 및 실행

- 참고
  - 자바스크립트는 인터프리터 언어
  - V8엔진의 경우, 터보팬이라 불리는 JIT 컴파일러를 사용
  - JIT 컴파일러는 자바스크립트 코드를 실행할 때, 바이트코드를 기계어로 변환하여 실행
  - 다른 엔진은? 
    - SpiderMonkey(모질라), Chakra(마이크로소프트), JavaScriptCore(사파리)
    - V8엔진은 구글 크롬과 Node.js에서 사용 

---

## 리플로우와 리페인트
```javascript
if(
  - DOM API를 사용해 DOM이나 CSSOM을 변경하는 경우
  - 레이아웃을 다시 계산해야 하는 경우
) {
  - 리플로우 발생
} else if(
  - 페인팅만 필요한 경우 // 반드시 리플로우 -> 리페인트 와 같은 순차적인 것이 아님
) {
  - 리페인트 발생
}
```
- 리플로우는 레이아웃을 다시 계산하는 과정
- 리페인트는 페인팅을 다시 하는 과정

### script 태그의 위치
- script 태그는 HTML 문서의 head나 body에 위치할 수 있음  
- 위치에 따라 DOM API 작동 여부 달라짐
  - body에 위치할 경우, DOMContentLoaded 이벤트가 발생한 후에 실행
  - 또한, 자바스크립트 실행되기 이전에 DOM생성 -> 페이지 로딩 시간 단축

- 참고
  - HTML5부터 `async`와 `defer` 속성이 추가됨 
    - `async` 속성은 HTML 문서의 파싱과 동시에 자바스크립트 파일을 다운로드
    - `defer` 속성은 HTML 문서의 파싱이 완료된 후에 자바스크립트 파일을 다운로드
  => `async`와 `defer` 속성을 사용하면, DOMContentLoaded 이벤트가 발생하기 전에 자바스크립트 파일을 다운로드 할 수 있음 