# Ch-40-2 이벤트 전파와 위임

---

## 이벤트 전파
DOM 트리 구조에서 이벤트가 발생했을 때, 이벤트는 DOM 트리를 따라 전파됨. 이를 **이벤트 전파(event propagation)**라고 함
- 이벤트 전파는 3단계로 이루어짐
  1. 캡처링 단계 : 이벤트가 최상위 조상 노드에서 시작해 이벤트 타깃 노드까지 내려옴
  2. 타깃 단계 : 이벤트가 이벤트 타깃 노드에 도달
  3. 버블링 단계 : 이벤트가 이벤트 타깃 노드에서 시작해 최상위 조상 노드까지 올라감

### Ul, Li  예제
```html
<ul id="myList">
  <li id="item1">Item 1</li>
  <li id="item2">Item 2</li>
  <li id="item3">Item 3</li>
</ul>
```
- ul 요소의 두번 째 자식 요소인 li 요소(item2)를 클릭하면, 이벤트는 다음과 같이 전파된다.
  - 캡처링 단계 : window -> document -> html 요소 -> body 요소 -> ul 요소 -> item2 요소
  - 타깃 단계 : item2 요소에 도달
  - 버블링 단계 : item2 요소 -> ul 요소 -> body 요소 -> html 요소 -> document -> window
    - (버블링이란 이름의 이유 : 이벤트가 이벤트 타깃 노드에서 시작해 최상위 조상 노드까지 올라가기 때문 마치 물방울이 위로 올라가는 것처럼)
- 이때, target은 item2 요소, currentTarget은 이벤트 핸들러가 등록된 ul 요소이다.
- 캡처링 선별 위해선, `addEventListener` 메서드의 세 번째 인수에 true 전달
  - ex) `element.addEventListener('click', function() { alert('clicked!'); }, true);`
- 기본값은 false, 즉, 버블링 단계에서 이벤트 핸들러가 호출됨
- 물론, 상위 DOM 요소에서도 캐치 가능

### 버블링 false인 대표적 이벤트
- focus, blur, mouseenter, mouseleave, load, unload, abort, error 이벤트는 버블링이 발생하지 않음


## 이벤트 위임
- 이벤트 위임(event delegation)은 상위 DOM 요소에 이벤트 핸들러를 등록하고, 하위 DOM 요소에서 발생한 이벤트를 처리하는 기법
- 이벤트 위임을 사용하면, 많은 수의 자식 요소에 개별적으로 이벤트 핸들러를 등록할 필요 없이, 상위 요소에 한 번만 등록하면 됨

## DOM 요소의 기본 동작 조작
### preventDefault 메서드
- `Event.prototype.preventDefault()` 메서드는 이벤트의 기본 동작을 취소
- ex) a 요소의 클릭 이벤트의 기본 동작은 링크 이동, 이를 preventDefault 메서드로 취소 가능
  ```html
  <a href="https://www.example.com" id="myLink">Go to Example.com</a>
  <script>
    const myLink = document.getElementById('myLink');
    myLink.addEventListener('click', function(e) {
      e.preventDefault(); // 기본 동작 취소
      alert('Link click prevented!');
    });
  </script>
  ```
- ex) form 요소의 submit 이벤트의 기본 동작은 폼 제출, 이를 preventDefault 메서드로 취소 가능
  ```html
  <form id="myForm">
    <input type="text" name="name" required>
    <button type="submit">Submit</button>
  </form>
  <script>
    const myForm = document.getElementById('myForm');
    myForm.addEventListener('submit', function(e) {
      e.preventDefault(); // 기본 동작 취소
      alert('Form submission prevented!');
    });
  </script>
  ``` 

### stopPropagation 메서드
- `Event.prototype.stopPropagation()` 메서드는 이벤트 전파를 중단
- 상위 요소에 등록된 이벤트 핸들러가 호출되지 않도록 함, 즉 하위 DOM 요소의 이벤트를 개별적으로  처리하고 싶을 때 유용
- ex)
  ```html
  <div id="parent" style="padding: 20px; background-color: lightblue;">
    Parent Div
    <button id="child">Click Me</button>
  </div>
  <script>
    const parent = document.getElementById('parent');
    const child = document.getElementById('child');

    parent.addEventListener('click', function() {
      alert('Parent Div Clicked!');
    });

    child.addEventListener('click', function(e) {
      e.stopPropagation(); // 이벤트 전파 중단
      alert('Child Button Clicked!');
    });
  </script>


## 방식별 this
### 이벤트 핸들러 어트리뷰트 방식
- 이벤트 핸들러 어트리뷰트 방식에서 this는 window 객체를 가리킴

### 이벤트 핸들러 프로퍼티와 addEventListener 메서드 방식
- 이벤트 핸들러 프로퍼티와 addEventListener 메서드 방식에서 this는 이벤트 핸들러가 등록된 요소를 가리킴

## 커스텀 이벤트
- 자바스크립트 코드에 의해 인위적으로 생성한 이벤트
- `CustomEvent` 생성자를 사용하여 커스텀 이벤트 객체를 생성
- `CustomEvent` 생성자의 문법
  - `new CustomEvent(type, [eventInitDict])`
    - type : 이벤트 타입을 나타내는 문자열
    - eventInitDict : 선택적 객체, 커스텀 이벤트의 속성을 정의
      - detail : 커스텀 이벤트에 전달할 추가 데이터
      - bubbles : 이벤트가 버블링되는지 여부, 기본값 false
      - cancelable : preventDefault()를 호출하여 이벤트의 기본 동작을 취소할 수 있는지 여부, 기본값 false
- ex)
  ```javascript
  // 커스텀 이벤트 생성
  const myEvent = new CustomEvent('myEvent', {
    detail: { message: 'Hello, Custom Event!' },
    bubbles: true,
    cancelable: true
  }); 
  // 이벤트 핸들러 등록
  const element = document.getElementById('myElement');
  element.addEventListener('myEvent', function(e) {
    console.log(e.detail.message); // 'Hello, Custom Event!'
  });
  // 커스텀 이벤트 디스패치
  element.dispatchEvent(myEvent);
  ```


### 커스텀 이벤트 디스패치
  - `EventTarget.prototype.dispatchEvent()` 메서드를 사용하여 커스텀 이벤트를 디스패치
  - 디스패치를 통해 이벤트 핸들러가 호출되고, 이벤트 객체가 이벤트 핸들러에 전달
  - `dispatchEvent` 메서드의 문법
    - `target.dispatchEvent(event)`
      - target : 이벤트를 디스패치할 대상 요소
      - event : 디스패치할 이벤트 객체
  