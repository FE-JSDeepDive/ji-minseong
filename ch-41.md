# Ch-41 타이머


---

## 호출 스케줄링
- 요약
  - `setTimeout` : 일정 시간 후에 콜백 함수 호출
  - `setInterval` : 일정 시간 간격으로 콜백 함수 반복 호출
  - `clearTimeout` : `setTimeout`으로 예약된 호출 취소
  - `clearInterval` : `setInterval`으로 예약된 반복 호출 취소

## 타이머 함수
### setTimeout
```javascript 
setTimeout(func|code, delay, [arg1, arg2, ...])
```
- func|code : **일정 시간 후**에 호출할 함수 또는 실행할 코드 문자열
- delay : 밀리초 단위의 지연 시간
- arg1, arg2, ... : func이 함수인 경우 전달할 인수들
- setTimeout 함수는 고유한 타이머 ID를 반환, 이 ID는 clearTimeout 함수에 전달하여 타이머를 취소하는 데 사용
  
- ex) 2초 후에 "Hello, World!" 출력
  ```javascript
  setTimeout(() => {
    console.log("Hello, World!");
  }, 2000);
  ```
### setInterval
```javascript
setInterval(func|code, delay, [arg1, arg2, ...])
```
- func|code : **일정 시간 간격**으로 호출할 함수 또는 실행할 코드 문자열
- delay : 밀리초 단위의 간격 시간
- arg1, arg2, ... : func이 함수인 경우 전달할 인수들
- `clearInterval` 함수를 사용하여 반복 호출을 중지할 수 있음


## 디바운스와 스로틀링
- 요약
  - 디바운스: 마지막 이벤트 발생 후 일정 시간 동안 추가 이벤트가 발생하지 않을 때에만 콜백 함수 실행
  - 스로틀링: 일정 시간 간격으로 콜백 함수 실행
### 디바운스 (Debounce)
- 이벤트가 연속적으로 발생할 때, 마지막 이벤트 발생 후 일정 시간 동안 추가 이벤트가 발생하지 않을 때에만 콜백 함수 실행
  
- ex) 사용자가 입력을 멈춘 후에만 검색어 자동 완성 기능 실행
```javascript
function debounce(func, wait) { // func: 콜백 함수, wait: 대기 시간 (밀리초)
  let timerId; // 타이머 ID
  return function(...args) { // 반환된 함수 args: 콜백 함수에 전달할 인수들 ,클로저 사용
    if (timerId) clearTimeout(timerId); // 기존 타이머 취소
    timerId = setTimeout(() => func.apply(this, args), wait); // 새로운 타이머 설정
  };
}

$input.addEventListener('input', debounce(function(event) {
  // 검색어 자동 완성 기능 실행
  postSearchSuggestions(event.target.value); //postSearchSuggestions: 검색어 자동 완성 함수
}, 300)); // 300ms 대기 후 실행
```
--> 쉽게 설명하면, 사용자가 입력을 멈춘 후에만 콜백 함수를 실행하는 것 그리고 이를 돕는게 debounce 함수이다.



### 스로틀링 (Throttling)
- 이벤트가 연속적으로 발생할 때, 일정 시간 간격으로 콜백 함수 실행
- ex) 사용자가 스크롤할 때, 일정 간격으로만 위치 정보를 서버에 전송 (스로틀링 방식)
```javascript
function throttle(func, limit) { // func: 콜백 함수, limit: 시간 간격 (밀리초)
  let lastFunc; // 마지막 타이머 ID
  let lastRan; // 마지막 실행 시간
  return function(...args) { // ...args: 콜백 함수에 전달할 인수들 ,클로저 사용
    if (!lastRan) { // 처음 실행
      func.apply(this, args); // 콜백 함수 실행
      lastRan = Date.now(); // 마지막 실행 시간 기록
    } else { // 이후 실행
      clearTimeout(lastFunc); // 기존 타이머 취소
      lastFunc = setTimeout(() => { // 새로운 타이머 설정
        if ((Date.now() - lastRan) >= limit) {
          func.apply(this, args);
          lastRan = Date.now();
        }
      }, limit - (Date.now() - lastRan));
    }
  };
}
```

```javascript
const throttle = (callback, delay) => {
  let timerId;
  // throttle 함수는 timerId를 기억하는 클로저를 반환
  return event => {
    if (timerId) return; // 타이머가 이미 설정되어 있으면 무시
    timerId = setTimeout(() => { // delay 후에 콜백 함수 실행
      callback(event);
      timerId = null; // 타이머 ID 초기화
    }, delay);
  }
}
```
-> 쉽게 설명하면, 너무 많이 스크롤 하는 것을 방지 하기 위해서, 일정 시간 간격으로만 콜백 함수를 실행하는 것 그리고 이를 돕는게 throttle 함수이다.

```javascript
window.addEventListener('scroll', throttle(() => {
  console.log('Scroll event handled!');
}, 200));
```
-> 스크롤 이벤트가 발생할 때마다 throttle 함수가 호출되고, 이 함수는 200밀리초 간격으로만 콜백 함수를 실행한다. 따라서 스크롤 이벤트가 너무 자주 발생해도 콘솔 로그는 200밀리초에 한번만 출력된다.
