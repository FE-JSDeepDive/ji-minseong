# Ch-46 제너레이터와 async/await

---

## 제너레이터란?
- ES6에서 도입된 제너레이터는 함수의 실행을 중간에 멈췄다가 다시 시작할 수 있는 특별한 함수

### 제너레이터 함수와 일반 함수의 차이
- 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 넘길 수 있다. 
  - 일반 함수 : 함수 호출 -> 제어권이 함수에게 넘어감 -> 함수 코드 일괄 실행
  - 제너레이터 함수 : 함수 호출 -> 제어권이 함수에게 넘어감 -> yield 키워드에서 제어권 호출자에게 반환 -> 다시 제어권 넘겨받아 실행 재개 , 즉 **함수의 제어권을 함수가 독점하는 것이 아니라 함수 호출자에게 양도(yield)할 수 있다**
- 제너레이터 함수는 함수 호출자와 함수의 상태를 주고 받을 수 있다.
  - 일반 함수 : 함수 호출 -> 매개변수로 값 전달 -> 함수 코드 실행 -> return 키워드로 값 반환
  - 제너레이터 함수 : 함수 호출 -> 매개변수로 값 전달 -> yield 키워드로 값 반환 -> next 메서드로 다시 제어권 넘겨받아 실행 재개 -> next 메서드의 인수로 값 전달 (양방향 통신 가능
- 제너레이터 함수를 호출 하면 제너레이터 객체를 반환한다. 
  - 일반 함수 : 함수 호출 -> 함수 코드 실행 -> return 키워드로 값 반환
  - 제너레이터 함수 : 함수 호출 -> **함수를 코드를 실행 하는 것이 아니라, 제너레이터 객체(이터러블, 동시에 이터레이터인)를 반환** -> next 메서드를 호출하여 제너레이터 함수의 실행을 재개

## 제너레이터 함수의 정의
- function* 키워드로 정의
- 하나 이상의 yield 키워드를 포함 (이로 함수 실행을 중간에 멈출 수 있음)
```js
// 제너레이터 함수 선언문
function* genDecFunc() {
  yield 1;
}

// 제너레이터 함수 표현식
const getExpFunc = function* (){
  yield 1;
}

// 제너레이터 메서드
const obj = {
  *genObjMethod() {
    yield 1;
  }
};

// 제너레이터 클래스 메서드
class MyClass {
  *genClassMethod() {
    yield 1;
  }
}
```
- '*' 위치는 상관 없이 function 키워드 바로 뒤 또는 메서드 이름 바로 앞에 위치
  - ex) `function *foo() {}` , `function* foo() {}` , `const obj = { *foo() {} }`
  - **하지만, 일관성을 위해 function* 또는 *genObjMethod() 형태로 사용하는 것이 좋다.** 
- 제너레이터 함수는 화살표 함수로 정의할 수 없다. (yield 키워드를 사용할 수 없기 때문)
- 제너레이터 함수는 new 연산자와 함께 호출할 수 없다. (제너레이터 함수는 constructor가 아니기 때문)

## 제너레이터 객체
- **제너레이터 함수를 호출하면 제너레이터 객체를 반환**
- **제너레이터 객체는 이터러블이면서 동시에 이터레이터인**
  - 이터러블 : Symbol.iterator 메서드를 갖고 있는 객체
  - 이터레이터 : next 메서드를 갖고 있는 객체 (next 메서드는 이터레이터 프로토콜을 준수하는(== 이터레이터 result 객체를 반환하는) 메서드)
- 제너레이터 객체는 next, return, throw 메서드를 갖고 있는 이터레이터
  - next 메서드 : 제너레이터 함수의 실행을 재개
    - next 메서드를 호출하면 제너레이터 함수의 실행이 재개되고, yield 키워드에서 다시 중단
    - next 메서드는 value와 done 프로퍼티를 갖는 객체를 반환
      - value : yield 키워드 다음에 오는 표현식의 값
      - done : 제너레이터 함수의 마지막까지 실행이 완료되었는지 여부를 나타내는 불리언 값
    - next 메서드의 인수 : 제너레이터 함수의 실행이 재개될 때, yield 키워드가 반환하는 값
      - 즉, next 메서드의 인수는 제너레이터 함수의 실행 컨텍스트에 값을 전달하는 역할을 한다. 

## 제너레이터의 일시 중지와 재개
- **yield 키워드는 제너레이터 함수의 실행을 일시 중지하고, 호출자에게 제어권을 반환하는 역할을 한다.**
- 제너레이터 함수는 yield 키워드에서 중단된 후, next 메서드를 호출하여 다시 실행을 재개할 수 있다.
```js
function* genFunc() {
  // 처음 next 메서드를 호추하면 첫번째 yield까지 실행되고 일시 중지
  // 이 때, yield된 값 1은 next 메서드가 반환하는 이터레이터 리절트 객체의 value 프로퍼티 값이 된다.
  // x 변수에는 아직 undefined가 할당되어 있다. x 변수의 값은 next 메서드가 두번째 호출될 때 전달된 인수가 할당된다.
  const x = yield 1;
  
  // 두 번째 next 메서드를 호출 할때, 전달한 인수 10은 첫 번째 yield 표현식을 할당 받는
  // x 변수에 할당된다. 즉 const x = yield 1; 는 두 번째 next 메서드가 호출될 때 완료 된다.
  // 두번째 next 메서드를 호출하면, 두 번째 표현식까지 실행되고 다시 일시 중지
  // 이 때, yield된 값  x + 10은 next 메서드가 반환하는 이터레이터 리절트 객체의 value 프로퍼티 값이 된다.
  const y = yield (x + 10);

  // 세 번째 next 메서드를 호출 할때, 전달한 인수 20은 두 번째 yield 표현식을 할당 받는 y 변수에 할당된다.
  // 즉, const y = yield (x + 10); 는 세 번째 next 메서드가 호출될 때 완료 된다.
  // 세 번째 next 메서드를 호출하면, 함수 끝까지 실행되고 완료된다.
  // 이때 제너레이터 함수의 반환값 x + y는 next 메서드가 반환하는 이터레이터 리절트 객체의 value 프로퍼티 값이 된다. 일반적으로 제너레이터 반환값은 의미가 없다.
  // 따라서, 제너레이터에서는 값을 반환할 필요가 없고, return은 종료의 의미로만 사용한다.
  return x + y;
}

// 제너레이터 함수를 호출하면 제너레이터 객체를 반환
// 이터러블이면서 동시에 이터레이터인 제너레이터 객체는 next 메서드를 갖고 있다.  
const generator = genFunc(0);

// 처음 호출 하는 next 메서드는 인수를 전달하지 않는다.
// 만약 처음 호출하는 next 메서드에 인수를 전달하면 무시된다.
// next 메서드가 반환한 이터레이터 리절트 객체의 value 프로퍼티에는 첫 번째 yield된 값 1이 할당된다.
let res = generator.next(); 
console.log(res);// { value: 1, done: false }

// next 메서드에 10을 전달 ->  genFun 함수의 x 변수에 할당
// next 메서드가 반환한 이터레이터 리절트 객체의 value 프로퍼티에는 두 번째 yield된 값 x + 10, 즉 20이 할당된다.
res = generator.next(10); 
console.log(res); // { value: 20, done: false }

// next 메서드에 20을 전달 ->  genFun 함수의 y 변수에 할당
// next 메서드가 반환한 이터레이터 리절트 객체의 value 프로퍼티에는 제너레이터 함수의 반환값 x + y, 즉 30이 할당된다.
res = generator.next(20);
console.log(res); // { value: 30, done: true }
```

## 제너레이터의 활용
### 이터러블 구현
- 제너레이터 함수를 사용하면 이터러블을 간편하게 구현할 수 있다.
```js
// 1부터 n까지의 정수를 순차적으로 생성하는 이터러블을 생성하는 제너레이터 함수
function* createRange(n) {
  for (let i = 1; i <= n; i++) {
    yield i;
  }
} 

const range = createRange(3);
console.log(range.next()); // { value: 1, done: false }
console.log(range.next()); // { value: 2, done: false }
console.log(range.next()); // { value: 3, done: false }
console.log(range.next()); // { value: undefined, done: true }


// 무한 이터러블을 생성하는 제너레이터 함수
const infinite = (function () {
  let [pre,cur] = [0,1];
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      [pre, cur] = [cur, pre + cur];
      // 무한 이터러블이므로 done 프로퍼티 값은 항상 false 이므로 생략
      return { value: cur };
    }
  }
}());

// infinite 이터러블은 무한 이터러블이므로 for...of문으로 순회할 수 없다.
// for (const num of infinite) {
//   console.log(num); // 1 1 2 3 5 8 13 21 ...
// }

for(const num of infinite) {
  if (num > 10000) break; // 10000 이하까지만 출력
  console.log(num); // 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765
} 

// 피보나치 수열
const fibo = = (function* () {
  let [pre,cur] = [0,1];
  while (true) {
    [pre, cur] = [cur, pre + cur];
    yield cur;
  }
}());

for(const num of fibo) {
  if (num > 10000) break; // 10000 이하까지만 출력
  console.log(num); // 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765
} 

```

### 비동기 처리
- 프로미스 비동기 처리를 동기 처럼 구현 가능
```js
const fetch = require('node-fetch'); // Node.js 환경에서 fetch 함수를 사용하기 위해 node-fetch 모듈을 임포트

const async = generatorFunc => {
  const generator = generatorFunc() ;// 2

  const onResolved = arg => {
    const result = generator.next(arg); // 5

    return result.done
    ? result.value // 9
    : result.value.then(res => onResolved(res)); // 7
  };

  return onResolved; // 3
};

(async function* fetchTodo() { // 1
  const url = 'https://jsonplaceholder.typicode.com/todos/1';
  const res = yield fetch(url); // 6
  const todo = yield res.json(); // 8
  console.log(todo); // { userId: 1, id: 1, title: 'delectus aut autem', completed: false } 
})(); // 4
```
- 과저 요약
  - 1. 제너레이터 함수 fetchTodo는 비동기 작업을 수행하는 제너레이터 함수로 정의
  - 2. async 함수는 제너레이터 함수를 호출하여 제너레이터 객체를 생성
  - 3. async 함수는 onResolved 함수를 반환, 이 함수는 프로미스가 해결될 때마다 호출
  - 4. fetchTodo 제너레이터 함수가 즉시 실행
  - 5. onResolved 함수는 제너레이터의 next 메서드를 호출하여 제너레이터 함수의 실행을 재개 
  - 6. fetch 함수가 반환한 프로미스가 yield 키워드에 의해 제너레이터 함수에서 일시 중지
  - 7. 프로미스가 해결되면, onResolved 함수가 다시 호출 
  - 8. onResolved 함수는 제너레이터의 next 메서드를 호출하여 제너레이터 함수의 실행을 재개
  - 9. 제너레이터 함수가 완료되면, 최종 결과를 반환
  - 즉, 제너레이터 함수의 yield 키워드를 사용하여 비동기 작업을 동기 처리처럼 작성할 수 있다.


## async/await
- 위를 보면 알겠듯이, 제너레이터를 사용하여 비동기 처리를 동기 처리처럼 구현할 수 있지만, 코드가 복잡해질 수 있다.
- ES2017(ES8)에서 도입된 async/await 문법은 제너레이터를 사용한 비동기 처리보다 더 간결하고 직관적으로 비동기 처리를 작성할 수 있게 한다.
- async/await는 프로미스를 기반으로 동작한다.
- async/await는 제너레이터와 달리 함수 실행을 중간에 멈추지 않는다. 
  - async 함수는 항상 프로미스를 반환한다.
  - await 키워드는 프로미스가 처리될 때까지 async 함수의 실행을 일시 중지하는 것이 아니라, 프로미스가 처리될 때까지 async 함수 내부의 코드 실행을 기다린다.
  - 즉, await 키워드는 async 함수 내부에서만 사용할 수 있다.

### async
- async 함수는 비동기 작업을 수행하는 함수로, 항상 프로미스를 반환한다.
```js
async function asyncFunc() {
  // 비동기 작업 수행
  const result = await someAsyncOperation();
  console.log(result);
}
```

### await
- await 키워드는 async 함수 내부에서만 사용할 수 있으며, 프로미스가 처리될 때까지 async 함수의 실행을 일시 중지한다.
- await 키워드는 settled 상태까지 대기한다. (fulfilled 또는 rejected), settled 상태가 되면, 프로미스의 처리 결과를 반환한다.
```js
// 예제 1 : 6초 소요
async function foo(){
const a = await new Promise(resolve => setTimeout(() => resolve(1), 3000));
const b = await new Promise(resolve => setTimeout(() => resolve(2), 2000));
const c = await new Promise(resolve => setTimeout(() => resolve(3), 1000));

console.log([a, b, c]); // [1, 2, 3]
}

// 예제 1에서 각각 3개의 비동기 처리는, 연관이 없는 비동기 처리이므로 순차 처리보다 병렬 처리하는 것이 더 효율적이다.
// Promise.all 메서드를 사용하여 병렬 처리할 수 있다.
// 예제 2 : 3초 소요
async function bar(){
  const [a, b, c] = await Promise.all([
    new Promise(resolve => setTimeout(() => resolve(1), 3000)),
    new Promise(resolve => setTimeout(() => resolve(2), 2000)),
    new Promise(resolve => setTimeout(() => resolve(3), 1000))
  ]);
  console.log([a, b, c]); // [1, 2, 3]
}

// 하지만 연관이 있다면 순차 처리가 맞다.
// 예제 3 : 6초 소요
async function bar(n){
  const a = await new Promise(resolve => setTimeout(() => resolve(n), 3000));
  const b = await new Promise(resolve => setTimeout(() => resolve(a + 1), 2000));
  const c = await new Promise(resolve => setTimeout(() => resolve(b + 1), 1000));
  console.log([a, b, c]); // [1, 2, 3]
}

```

### 에러 처리
- 앞서 비동기 처리를 위한 콜백 패턴의 단점 중 하나는 에러 처리가 어렵다는 점이었다.
- 프로미스는 then 메서드의 두 번째 인수로 에러 처리를 할 수 있지만, catch 메서드를 사용하는 것이 더 일반적이다.
- async/await는 동기 처리와 마찬가지로 try/catch 문을 사용하여 에러 처리를 할 수 있다.
```js
// 콜백 패턴
try{
  setTimeout(() => {
    throw new Error('Error!');
  }, 1000);
} catch (error) {
  console.error(error); // Uncaught Error: Error!, 에러를 잡지 못함
}

// async/await
const fetch = require('node-fetch');

async function fetchTodo() {
  try {
    const url = 'https://jsonplaceholder.typicode.com/todos/1';
    const res = await fetch(url);
    const todo = await res.json();
    console.log(todo); // { userId: 1, id: 1, title: 'delectus aut autem', completed: false }
  } catch (error) {
    console.error(error); // 네트워크 에러 또는 JSON 파싱 에러를 잡을 수 있음
  }
}
```
- async 함수 내에서 catch문을 사용하지 않으면, async 함수가 반환하는 프로미스가 rejected 상태가 된다.
- 따라서, async 함수를 호출하고, Promise.prototype.catch 메서드를 사용하여 에러를 처리할 수 있다.
```js
const fetch = require('node-fetch');

async function fetchTodo() {
  const url = 'https://jsonplaceholder.typicode.com/todos/1';
  const res = await fetch(url);
  const todo = await res.json();
  console.log(todo);
}

fetchTodo().catch(error => {
  console.error(error);
});
```

