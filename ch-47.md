# Ch-47 에러 처리

---

## 에러 처리의 필요성
에러가 없는건 불가능 -> 에러 처리가 중요 
방법은 크게 2가지
1. 예외적 상황 발생하면 반환하는 값을 if, 단축 평가, 옵셔널 체이닝 등으로 처리
2. 에러가 발생하면 에러 처리 코드로 점프

## try ...catch...finally 문
**이는 2번째 방법에 해당**
```js
  try{
    // 에러가 발생할 가능성이 있는 코드
  } catch (error) {
    // 에러가 발생했을 때 실행할 코드
  } finally {
    // 에러 발생 여부와 상관없이 항상 실행할 코드
  }
```

## Error 객체
`const error = new Error(message);`
- message: 에러 메시지
- stack: 에러가 발생시킨 콜스택의 호출 정보를 나타내는 문자열 -> 디버깅을 위해 사용

### 총 7가지 내장 에러 객체
- Error: 일반적인 에러
- SyntaxError: 구문 오류가 발생했을 때 발생하는 에러
- ReferenceError: 참조할 수 없는 변수를 참조할 때 발생하는 에러
- TypeError: 데이터 타입이 맞지 않을 때 발생하는 에러
- RangeError: 숫자가 허용된 범위를 벗어난 경우 발생하는 에러
- URIError: URI 처리 함수에서 잘못된 인수를 전달했을 때 발생하는 에러
- EvalError: eval() 함수와 관련된 에러 (현재는 사용되지 않음)
- InternalError: 자바스크립트 엔진 내부에서 발생하는 에러 (비표준, 일부 환경에서만 지원)

### 예시
```js
1 @ 1; // SyntaxError: Unexpected number
let x = y; // ReferenceError: y is not defined
null.f(); // TypeError: Cannot read property 'f' of null
new Array(-1); // RangeError: Invalid array length
decodeURIComponent('%'); // URIError: URI malformed
```

## throw 문
**에러 객체 생성** != **에러 발생**
```js
throw expression; // expression은 에러 객체일 수도 있고, 문자열, 숫자 등 어떤 값도 가능
```

```js
try {
  throw new Error('에러 발생!');
} catch (e) {
  console.log(e.message); // '에러 발생!'
}
```
## 에러의 전파
기존의 프로미스에서 콜백 패턴을 해결했듯이, 에러는 호출자 에게 전파된다.
```js
function a() {
  b();
}
function b() {
  c();
}
function c() {
  throw new Error('에러 발생!');
}
a();
```
- 위 예시에선, `c()` 함수에서 에러가 발생하고, 이 에러는 `b()` 함수를 거쳐 `a()` 함수로 전파된다.
- 에러가 발생하면 호출 스택을 따라 상위 함수로 전파된다.
- try...catch 문으로 에러를 잡을 수 있다.
**주의** setTimeout,이나 프로미스 후속 처리 메서드 then, catch, finally 내부에서 발생한 에러는 호출 스택을 따라 전파되지 않는다.

## 사용자 정의 에러
```js
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = 'CustomError'; // 에러 이름 설정
  }
} 
try {
  throw new CustomError('사용자 정의 에러 발생!');
} catch (e) {
  console.log(e.name); // 'CustomError'
  console.log(e.message); // '사용자 정의 에러 발생!'
}
```